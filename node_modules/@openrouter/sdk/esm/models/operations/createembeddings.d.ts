import * as z from "zod/v4";
import { ClosedEnum, OpenEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";
import * as models from "../index.js";
export type Input = string | Array<string> | Array<number> | Array<Array<number>>;
/**
 * Data collection setting. If no available model provider meets the requirement, your request will return an error.
 *
 * @remarks
 * - allow: (default) allow providers which store user data non-transiently and may train on it
 * - deny: use only providers which do not collect user data.
 */
export declare const DataCollection: {
    readonly Deny: "deny";
    readonly Allow: "allow";
};
/**
 * Data collection setting. If no available model provider meets the requirement, your request will return an error.
 *
 * @remarks
 * - allow: (default) allow providers which store user data non-transiently and may train on it
 * - deny: use only providers which do not collect user data.
 */
export type DataCollection = OpenEnum<typeof DataCollection>;
export type Order = models.ProviderName | string;
export type Only = models.ProviderName | string;
export type Ignore = models.ProviderName | string;
/**
 * The sorting strategy to use for this request, if "order" is not specified. When set, no load balancing is performed.
 */
export declare const Sort: {
    readonly Price: "price";
    readonly Throughput: "throughput";
    readonly Latency: "latency";
};
/**
 * The sorting strategy to use for this request, if "order" is not specified. When set, no load balancing is performed.
 */
export type Sort = OpenEnum<typeof Sort>;
/**
 * The object specifying the maximum price you want to pay for this request. USD price per million tokens, for prompt and completion.
 */
export type MaxPrice = {
    /**
     * A value in string or number format that is a large number
     */
    prompt?: any | undefined;
    /**
     * A value in string or number format that is a large number
     */
    completion?: any | undefined;
    /**
     * A value in string or number format that is a large number
     */
    image?: any | undefined;
    /**
     * A value in string or number format that is a large number
     */
    audio?: any | undefined;
    /**
     * A value in string or number format that is a large number
     */
    request?: any | undefined;
};
export type CreateEmbeddingsProvider = {
    /**
     * Whether to allow backup providers to serve requests
     *
     * @remarks
     * - true: (default) when the primary provider (or your custom providers in "order") is unavailable, use the next best provider.
     * - false: use only the primary/custom provider, and return the upstream error if it's unavailable.
     */
    allowFallbacks?: boolean | null | undefined;
    /**
     * Whether to filter providers to only those that support the parameters you've provided. If this setting is omitted or set to false, then providers will receive only the parameters they support, and ignore the rest.
     */
    requireParameters?: boolean | null | undefined;
    /**
     * Data collection setting. If no available model provider meets the requirement, your request will return an error.
     *
     * @remarks
     * - allow: (default) allow providers which store user data non-transiently and may train on it
     * - deny: use only providers which do not collect user data.
     */
    dataCollection?: DataCollection | null | undefined;
    /**
     * Whether to restrict routing to only ZDR (Zero Data Retention) endpoints. When true, only endpoints that do not retain prompts will be used.
     */
    zdr?: boolean | null | undefined;
    /**
     * Whether to restrict routing to only models that allow text distillation. When true, only models where the author has allowed distillation will be used.
     */
    enforceDistillableText?: boolean | null | undefined;
    /**
     * An ordered list of provider slugs. The router will attempt to use the first provider in the subset of this list that supports your requested model, and fall back to the next if it is unavailable. If no providers are available, the request will fail with an error message.
     */
    order?: Array<models.ProviderName | string> | null | undefined;
    /**
     * List of provider slugs to allow. If provided, this list is merged with your account-wide allowed provider settings for this request.
     */
    only?: Array<models.ProviderName | string> | null | undefined;
    /**
     * List of provider slugs to ignore. If provided, this list is merged with your account-wide ignored provider settings for this request.
     */
    ignore?: Array<models.ProviderName | string> | null | undefined;
    /**
     * A list of quantization levels to filter the provider by.
     */
    quantizations?: Array<models.Quantization> | null | undefined;
    /**
     * The sorting strategy to use for this request, if "order" is not specified. When set, no load balancing is performed.
     */
    sort?: Sort | null | undefined;
    /**
     * The object specifying the maximum price you want to pay for this request. USD price per million tokens, for prompt and completion.
     */
    maxPrice?: MaxPrice | undefined;
};
export declare const EncodingFormatBase64: {
    readonly Base64: "base64";
};
export type EncodingFormatBase64 = ClosedEnum<typeof EncodingFormatBase64>;
export declare const EncodingFormatFloat: {
    readonly Float: "float";
};
export type EncodingFormatFloat = ClosedEnum<typeof EncodingFormatFloat>;
export type EncodingFormat = EncodingFormatFloat | EncodingFormatBase64;
export type CreateEmbeddingsRequest = {
    input: string | Array<string> | Array<number> | Array<Array<number>>;
    model: string;
    provider?: CreateEmbeddingsProvider | undefined;
    encodingFormat?: EncodingFormatFloat | EncodingFormatBase64 | undefined;
    user?: string | undefined;
};
export declare const ObjectT: {
    readonly List: "list";
};
export type ObjectT = ClosedEnum<typeof ObjectT>;
export declare const ObjectEmbedding: {
    readonly Embedding: "embedding";
};
export type ObjectEmbedding = ClosedEnum<typeof ObjectEmbedding>;
export type Embedding = Array<number> | string;
export type CreateEmbeddingsData = {
    object: ObjectEmbedding;
    embedding: Array<number> | string;
    index?: number | undefined;
};
export type Usage = {
    promptTokens: number;
    totalTokens: number;
    cost?: number | undefined;
};
/**
 * Embedding response
 */
export type CreateEmbeddingsResponseBody = {
    id?: string | undefined;
    object: ObjectT;
    data: Array<CreateEmbeddingsData>;
    model: string;
    usage?: Usage | undefined;
};
export type CreateEmbeddingsResponse = CreateEmbeddingsResponseBody | string;
/** @internal */
export type Input$Outbound = string | Array<string> | Array<number> | Array<Array<number>>;
/** @internal */
export declare const Input$outboundSchema: z.ZodType<Input$Outbound, Input>;
export declare function inputToJSON(input: Input): string;
/** @internal */
export declare const DataCollection$outboundSchema: z.ZodType<string, DataCollection>;
/** @internal */
export type Order$Outbound = string | string;
/** @internal */
export declare const Order$outboundSchema: z.ZodType<Order$Outbound, Order>;
export declare function orderToJSON(order: Order): string;
/** @internal */
export type Only$Outbound = string | string;
/** @internal */
export declare const Only$outboundSchema: z.ZodType<Only$Outbound, Only>;
export declare function onlyToJSON(only: Only): string;
/** @internal */
export type Ignore$Outbound = string | string;
/** @internal */
export declare const Ignore$outboundSchema: z.ZodType<Ignore$Outbound, Ignore>;
export declare function ignoreToJSON(ignore: Ignore): string;
/** @internal */
export declare const Sort$outboundSchema: z.ZodType<string, Sort>;
/** @internal */
export type MaxPrice$Outbound = {
    prompt?: any | undefined;
    completion?: any | undefined;
    image?: any | undefined;
    audio?: any | undefined;
    request?: any | undefined;
};
/** @internal */
export declare const MaxPrice$outboundSchema: z.ZodType<MaxPrice$Outbound, MaxPrice>;
export declare function maxPriceToJSON(maxPrice: MaxPrice): string;
/** @internal */
export type CreateEmbeddingsProvider$Outbound = {
    allow_fallbacks?: boolean | null | undefined;
    require_parameters?: boolean | null | undefined;
    data_collection?: string | null | undefined;
    zdr?: boolean | null | undefined;
    enforce_distillable_text?: boolean | null | undefined;
    order?: Array<string | string> | null | undefined;
    only?: Array<string | string> | null | undefined;
    ignore?: Array<string | string> | null | undefined;
    quantizations?: Array<string> | null | undefined;
    sort?: string | null | undefined;
    max_price?: MaxPrice$Outbound | undefined;
};
/** @internal */
export declare const CreateEmbeddingsProvider$outboundSchema: z.ZodType<CreateEmbeddingsProvider$Outbound, CreateEmbeddingsProvider>;
export declare function createEmbeddingsProviderToJSON(createEmbeddingsProvider: CreateEmbeddingsProvider): string;
/** @internal */
export declare const EncodingFormatBase64$outboundSchema: z.ZodEnum<typeof EncodingFormatBase64>;
/** @internal */
export declare const EncodingFormatFloat$outboundSchema: z.ZodEnum<typeof EncodingFormatFloat>;
/** @internal */
export type EncodingFormat$Outbound = string | string;
/** @internal */
export declare const EncodingFormat$outboundSchema: z.ZodType<EncodingFormat$Outbound, EncodingFormat>;
export declare function encodingFormatToJSON(encodingFormat: EncodingFormat): string;
/** @internal */
export type CreateEmbeddingsRequest$Outbound = {
    input: string | Array<string> | Array<number> | Array<Array<number>>;
    model: string;
    provider?: CreateEmbeddingsProvider$Outbound | undefined;
    encoding_format?: string | string | undefined;
    user?: string | undefined;
};
/** @internal */
export declare const CreateEmbeddingsRequest$outboundSchema: z.ZodType<CreateEmbeddingsRequest$Outbound, CreateEmbeddingsRequest>;
export declare function createEmbeddingsRequestToJSON(createEmbeddingsRequest: CreateEmbeddingsRequest): string;
/** @internal */
export declare const ObjectT$inboundSchema: z.ZodEnum<typeof ObjectT>;
/** @internal */
export declare const ObjectEmbedding$inboundSchema: z.ZodEnum<typeof ObjectEmbedding>;
/** @internal */
export declare const Embedding$inboundSchema: z.ZodType<Embedding, unknown>;
export declare function embeddingFromJSON(jsonString: string): SafeParseResult<Embedding, SDKValidationError>;
/** @internal */
export declare const CreateEmbeddingsData$inboundSchema: z.ZodType<CreateEmbeddingsData, unknown>;
export declare function createEmbeddingsDataFromJSON(jsonString: string): SafeParseResult<CreateEmbeddingsData, SDKValidationError>;
/** @internal */
export declare const Usage$inboundSchema: z.ZodType<Usage, unknown>;
export declare function usageFromJSON(jsonString: string): SafeParseResult<Usage, SDKValidationError>;
/** @internal */
export declare const CreateEmbeddingsResponseBody$inboundSchema: z.ZodType<CreateEmbeddingsResponseBody, unknown>;
export declare function createEmbeddingsResponseBodyFromJSON(jsonString: string): SafeParseResult<CreateEmbeddingsResponseBody, SDKValidationError>;
/** @internal */
export declare const CreateEmbeddingsResponse$inboundSchema: z.ZodType<CreateEmbeddingsResponse, unknown>;
export declare function createEmbeddingsResponseFromJSON(jsonString: string): SafeParseResult<CreateEmbeddingsResponse, SDKValidationError>;
//# sourceMappingURL=createembeddings.d.ts.map