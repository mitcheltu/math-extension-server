/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */
import * as z from "zod/v4";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import * as openEnums from "../../types/enums.js";
import * as models from "../index.js";
/**
 * Data collection setting. If no available model provider meets the requirement, your request will return an error.
 *
 * @remarks
 * - allow: (default) allow providers which store user data non-transiently and may train on it
 * - deny: use only providers which do not collect user data.
 */
export const DataCollection = {
    Deny: "deny",
    Allow: "allow",
};
/**
 * The sorting strategy to use for this request, if "order" is not specified. When set, no load balancing is performed.
 */
export const Sort = {
    Price: "price",
    Throughput: "throughput",
    Latency: "latency",
};
export const EncodingFormatBase64 = {
    Base64: "base64",
};
export const EncodingFormatFloat = {
    Float: "float",
};
export const ObjectT = {
    List: "list",
};
export const ObjectEmbedding = {
    Embedding: "embedding",
};
/** @internal */
export const Input$outboundSchema = z.union([
    z.string(),
    z.array(z.string()),
    z.array(z.number()),
    z.array(z.array(z.number())),
]);
export function inputToJSON(input) {
    return JSON.stringify(Input$outboundSchema.parse(input));
}
/** @internal */
export const DataCollection$outboundSchema = openEnums.outboundSchema(DataCollection);
/** @internal */
export const Order$outboundSchema = z.union([
    models.ProviderName$outboundSchema,
    z.string(),
]);
export function orderToJSON(order) {
    return JSON.stringify(Order$outboundSchema.parse(order));
}
/** @internal */
export const Only$outboundSchema = z.union([
    models.ProviderName$outboundSchema,
    z.string(),
]);
export function onlyToJSON(only) {
    return JSON.stringify(Only$outboundSchema.parse(only));
}
/** @internal */
export const Ignore$outboundSchema = z
    .union([models.ProviderName$outboundSchema, z.string()]);
export function ignoreToJSON(ignore) {
    return JSON.stringify(Ignore$outboundSchema.parse(ignore));
}
/** @internal */
export const Sort$outboundSchema = openEnums
    .outboundSchema(Sort);
/** @internal */
export const MaxPrice$outboundSchema = z
    .object({
    prompt: z.any().optional(),
    completion: z.any().optional(),
    image: z.any().optional(),
    audio: z.any().optional(),
    request: z.any().optional(),
});
export function maxPriceToJSON(maxPrice) {
    return JSON.stringify(MaxPrice$outboundSchema.parse(maxPrice));
}
/** @internal */
export const CreateEmbeddingsProvider$outboundSchema = z.object({
    allowFallbacks: z.nullable(z.boolean()).optional(),
    requireParameters: z.nullable(z.boolean()).optional(),
    dataCollection: z.nullable(DataCollection$outboundSchema).optional(),
    zdr: z.nullable(z.boolean()).optional(),
    enforceDistillableText: z.nullable(z.boolean()).optional(),
    order: z.nullable(z.array(z.union([models.ProviderName$outboundSchema, z.string()]))).optional(),
    only: z.nullable(z.array(z.union([models.ProviderName$outboundSchema, z.string()]))).optional(),
    ignore: z.nullable(z.array(z.union([models.ProviderName$outboundSchema, z.string()]))).optional(),
    quantizations: z.nullable(z.array(models.Quantization$outboundSchema))
        .optional(),
    sort: z.nullable(Sort$outboundSchema).optional(),
    maxPrice: z.lazy(() => MaxPrice$outboundSchema).optional(),
}).transform((v) => {
    return remap$(v, {
        allowFallbacks: "allow_fallbacks",
        requireParameters: "require_parameters",
        dataCollection: "data_collection",
        enforceDistillableText: "enforce_distillable_text",
        maxPrice: "max_price",
    });
});
export function createEmbeddingsProviderToJSON(createEmbeddingsProvider) {
    return JSON.stringify(CreateEmbeddingsProvider$outboundSchema.parse(createEmbeddingsProvider));
}
/** @internal */
export const EncodingFormatBase64$outboundSchema = z.enum(EncodingFormatBase64);
/** @internal */
export const EncodingFormatFloat$outboundSchema = z.enum(EncodingFormatFloat);
/** @internal */
export const EncodingFormat$outboundSchema = z.union([
    EncodingFormatFloat$outboundSchema,
    EncodingFormatBase64$outboundSchema,
]);
export function encodingFormatToJSON(encodingFormat) {
    return JSON.stringify(EncodingFormat$outboundSchema.parse(encodingFormat));
}
/** @internal */
export const CreateEmbeddingsRequest$outboundSchema = z.object({
    input: z.union([
        z.string(),
        z.array(z.string()),
        z.array(z.number()),
        z.array(z.array(z.number())),
    ]),
    model: z.string(),
    provider: z.lazy(() => CreateEmbeddingsProvider$outboundSchema).optional(),
    encodingFormat: z.union([
        EncodingFormatFloat$outboundSchema,
        EncodingFormatBase64$outboundSchema,
    ]).optional(),
    user: z.string().optional(),
}).transform((v) => {
    return remap$(v, {
        encodingFormat: "encoding_format",
    });
});
export function createEmbeddingsRequestToJSON(createEmbeddingsRequest) {
    return JSON.stringify(CreateEmbeddingsRequest$outboundSchema.parse(createEmbeddingsRequest));
}
/** @internal */
export const ObjectT$inboundSchema = z.enum(ObjectT);
/** @internal */
export const ObjectEmbedding$inboundSchema = z.enum(ObjectEmbedding);
/** @internal */
export const Embedding$inboundSchema = z.union([
    z.array(z.number()),
    z.string(),
]);
export function embeddingFromJSON(jsonString) {
    return safeParse(jsonString, (x) => Embedding$inboundSchema.parse(JSON.parse(x)), `Failed to parse 'Embedding' from JSON`);
}
/** @internal */
export const CreateEmbeddingsData$inboundSchema = z.object({
    object: ObjectEmbedding$inboundSchema,
    embedding: z.union([z.array(z.number()), z.string()]),
    index: z.number().optional(),
});
export function createEmbeddingsDataFromJSON(jsonString) {
    return safeParse(jsonString, (x) => CreateEmbeddingsData$inboundSchema.parse(JSON.parse(x)), `Failed to parse 'CreateEmbeddingsData' from JSON`);
}
/** @internal */
export const Usage$inboundSchema = z.object({
    prompt_tokens: z.number(),
    total_tokens: z.number(),
    cost: z.number().optional(),
}).transform((v) => {
    return remap$(v, {
        "prompt_tokens": "promptTokens",
        "total_tokens": "totalTokens",
    });
});
export function usageFromJSON(jsonString) {
    return safeParse(jsonString, (x) => Usage$inboundSchema.parse(JSON.parse(x)), `Failed to parse 'Usage' from JSON`);
}
/** @internal */
export const CreateEmbeddingsResponseBody$inboundSchema = z.object({
    id: z.string().optional(),
    object: ObjectT$inboundSchema,
    data: z.array(z.lazy(() => CreateEmbeddingsData$inboundSchema)),
    model: z.string(),
    usage: z.lazy(() => Usage$inboundSchema).optional(),
});
export function createEmbeddingsResponseBodyFromJSON(jsonString) {
    return safeParse(jsonString, (x) => CreateEmbeddingsResponseBody$inboundSchema.parse(JSON.parse(x)), `Failed to parse 'CreateEmbeddingsResponseBody' from JSON`);
}
/** @internal */
export const CreateEmbeddingsResponse$inboundSchema = z.union([
    z.lazy(() => CreateEmbeddingsResponseBody$inboundSchema),
    z.string(),
]);
export function createEmbeddingsResponseFromJSON(jsonString) {
    return safeParse(jsonString, (x) => CreateEmbeddingsResponse$inboundSchema.parse(JSON.parse(x)), `Failed to parse 'CreateEmbeddingsResponse' from JSON`);
}
//# sourceMappingURL=createembeddings.js.map